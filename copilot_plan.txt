# Attack Plan for Issue #149: Optional String-Filler for DEFS

## Issue Summary
Add optional multi-argument syntax to DEFS directive (similar to struct TEXT field) to support:
  DEFS 10, "name_1st"Z  -> 6e 61 6d 65 5f 31 73 74 00 00
  DEFS 10, "name_2"     -> 6e 61 6d 65 5f 32 32 32 32 32
  DEFS 10, "name_3 "    -> 6e 61 6d 65 5f 33 20 20 20 20
  DEFS 10, 1, 'x', 3    -> 01 78 03 03 03 03 03 03 03 03 (last byte fills remainder)

Current behavior: DEFS size[, fillbyte] - fills remaining with single byte (default 0x00)
Desired behavior: DEFS can accept DB-like operands (like struct TEXT), where last explicitly-defined byte becomes the filler

## Implementation Steps

### Phase 1: Research & Understanding of sjasmplus architecture

**Current DEFS Implementation** (dirBLOCK in sjasm/directives.cpp line 244):
- Parses size expression
- Optional comma followed by single expression (parsed as fillbyte)
- Calls EmitBlock(fillbyte, size) from sjasm/sjio.cpp line 465
- EmitBlock: emits `size` bytes, each byte is `fillbyte` (or preserves device memory if flag set)

**Key Reusable Functions** (for new operand parsing):
- GetBytes() in sjasm/reader.cpp line 654: Parses comma-separated operands → fills int array with bytes, terminated by -1 sentinel
  - Supports: expressions, string literals (with Z/C suffixes), AddressRelocation
  - 128-byte limit enforced at line 690: Error("Over 128 bytes defined...") if overflow
  - Used by: dirBYTE, dirDC, dirDZ, dirABYTE* and others (all use getBytesWithCheck wrapper)
- EmitBytes() in sjasm/sjio.cpp line 446: Emits array of bytes (int*), stops at BYTES_END_MARKER (-1 sentinel)
- EmitBlock() in sjasm/sjio.cpp line 465: Emits repeated byte for `size` bytes (preserveDeviceMemory aware)

**DEFB/BYTE Pattern** (to reuse for DEFS):
1. getBytesWithCheck() wrapper (sjasm/directives.cpp line 110) handles error checking
2. Calls GetBytes(lp, dirDx[130], add, dc) to parse operands into array
3. Calls EmitBytes(dirDx) to emit all bytes sequentially
4. Example: DEFB 1, 'x', 3 → dirDx[] = {1, 'x', 3, -1} → EmitBytes emits 1, x, 3 sequentially

**Task Checklist**:
- [ ] 1.0: Understand current DEFS (BLOCK) behavior ✓ dirBLOCK line 244 parses size + optional fillbyte, calls EmitBlock
- [ ] 1.1: Locate GetBytes() function (reusable for operand parsing) ✓ sjasm/reader.cpp line 654
- [ ] 1.2: Understand how DEFB uses GetBytes() to parse comma-separated operands into array ✓ getBytesWithCheck (line 110) pattern
- [ ] 1.3: Understand how operand bytes are emitted sequentially (EmitBytes takes int array, stops at -1 sentinel) ✓ EmitBytes line 446
- [ ] 1.4: Understand 128-byte limit (GetBytes enforces existing infrastructure) ✓ line 690 in GetBytes
- [ ] 1.5: Understand string literal suffix handling (Z=zero-terminate, C=high-bit): GetCharConstAsString() ✓ already handled
- [ ] 1.6: Examine error messages (compare DEFB overflow "Over 128 bytes..." to match style for DEFS) ✓ line 690 GetBytes
- [ ] 1.7: Study DEFB pattern: dirBYTE→getBytesWithCheck→GetBytes→EmitBytes (Vs. dirBLOCK→dirBLOCK→EmitBlock)
- [ ] 1.8: Understand three-pass correctness: all passes must advance program counter ($) by identical amount ✓ Pass 1-2 advance $ only, Pass 3 actually emits bytes; sjasmplus errors if Pass 2 ≠ Pass 3 advances
- [ ] 1.9: **CRITICAL DESIGN DECISION**: Approach option 1 (recommended): Parse operand list INSTEAD of single fillbyte, then emit operand bytes + padding
  - Example flow: DEFS 10, 1, 'x' → Call GetBytes → get [1, 'x', -1] → EmitBytes([1, 'x', -1]) → EmitBlock(last_operand='x', padding_count=8)
  - Backward compatible: DEFS 10, 5 → GetBytes → [5, -1] → EmitBytes([5, -1]) → EmitBlock(5, 9)
- [ ] 1.10: Approach option 2 (simpler but less clean): Convert operand array to padding byte, but what if operands don't fit? Need truncation logic anyway.

### Phase 2: Test-First Development (TDD approach)
- [ ] 2.0: **Create test file immediately after research**: `tests/parsing/defs_string_filler.asm`
- [ ] 2.0a: Write test using DB (DEFB) initially to generate desired output (machine code bytes)
- [ ] 2.0b: Run: `./sjasmplus --lst --lstlab=sort --color=off tests/parsing/defs_string_filler.asm` to generate listing
- [ ] 2.0c: Examine DB with 129+ args to see overflow error format, copy that style for DEFS
- [ ] 2.0d: **Create .lst file** matching test file name (`tests/parsing/defs_string_filler.lst`). **IMPORTANT**: paths in .lst must be local (relative), test runner compares generated vs provided .lst
- [ ] 2.0e: Replace DB lines with desired DEFS syntax in .asm file (test will now fail on listing mismatch)
- [ ] 2.0f: Patch .lst file accordingly (update "source part" of listing lines, after machine code bytes, to match new DEFS syntax)
- [ ] 2.0g: Verify test structure looks sound before changing sjasm source code
- [ ] 2.1: **Modify dirBLOCK()** in sjasm/directives.cpp to:
  - [ ] 2.1a: Parse size (existing code)
  - [ ] 2.1b: Check for comma - if present, call GetBytes() to parse operand list
  - [ ] 2.1c: If no comma, use default filler 0x00
  - [ ] 2.1d: **Key decision**: reuse GetBytes() directly or create GetBytes_v2() variant? (Research may show direct reuse is safe)
- [ ] 2.2: Handle backward compatibility: old `DEFS 10, 5` (single operand 5) works automatically with new parser
- [ ] 2.3: GetBytes() already handles string suffixes (Z, C) via GetCharConstAsString() - no additional logic needed
- [ ] 2.4: Test parser with: DEFS 10 | DEFS 10, 5 | DEFS 10, "x"Z | DEFS 10, 1, 'x', 3

### Phase 3: Implementation Logic
- [ ] 3.1: Implement operand list expansion (convert each operand to bytes, similar to TEXT)
- [ ] 3.2: Implement padding logic: if operands provided, last byte fills remaining (if no operands, default fill is 0x00)
- [ ] 3.2a: **Listing feature**: All explicit operand bytes must be shown fully in listing (no "..." truncation). Filler bytes can use "..." truncation via EmitBlock. This requires careful handling of ListEmittedBytes array to preserve explicit bytes before invoking filler emission.
  - Design note: Ellipsis may appear immediately after last explicit byte or with at least one implicit byte shown first - not a hard requirement, implementation will determine.
- [ ] 3.3: **Two overflow limits** (different errors):
  - GetBytes enforces 128-byte max for operand list (parser array limit): Error "Over 128 bytes defined in single DB/DC/... Values over"
  - DEFS size enforces max for initial emission: check AFTER GetBytes returns, before EmitBytes
  - If operand bytes > DEFS size: truncate to size and report DEFS-specific overflow error (exact message TBD)
- [ ] 3.4: Handle DEFS size overflow: if GetBytes returns array with total bytes > size, **truncate to size before EmitBytes**, capture last emitted byte as filler, **report overflow error** (message format TBD), then call EmitBlock(filler_byte, remaining_count)
- [ ] 3.5: Valid exact match: `DEFS 1, 'x'` emits single byte 'x', no error
- [ ] 3.6: All three passes advance program counter ($) correctly - Pass 1-2 advance $ only (no emission), Pass 3 emits to device/stream; verified by successful assembly (if $ advances differ between passes, sjasmplus errors automatically)
- [ ] 3.7: **Test both modes in same .asm file**: Use `DEVICE NONE` section for pipe/streaming mode, `DEVICE NOSLOT64K` section for virtual device mode

### Phase 4: Testing & Validation
- [ ] 4.1: Test file created during Phase 2 (`tests/parsing/defs_string_filler.asm` + `.lst`)
- [ ] 4.1a: **Device mode tests** (lines 48+ in .lst): Will be updated after NONE device implementation is verified. No significant implementation difference expected between device modes.
- [ ] 4.2: Run initial test to verify it fails (expected, before feature implementation)
- [ ] 4.3: Implement feature in directives.cpp to make test pass
- [ ] 4.4: After implementation, `.lst` should match expected output (minimal listing file updates if any)
- [ ] 4.5: Verify both pipe mode and device mode work correctly in listings
- [ ] 4.6: Test overflow error formatting matches design (exact message TBD during implementation)

### Phase 5: Integration & Cleanup
- [ ] 5.1: Update documentation (docs/documentation.xml) with new DEFS syntax
- [ ] 5.1a: **Add examples from Issue #149** to documentation (showcasing different filler scenarios):
  - `DEFS 10, "name_1st"Z` → zero-terminated string, rest filled with 0x00
  - `DEFS 10, "name_2"` → string, rest filled with last char ('2')
  - `DEFS 10, "name_3 "` → string with space, rest filled with space
  - `DEFS 10, 1, 'x', 3` → mixed operands, rest filled with last byte (3)
  - These showcase usage patterns for humans, low development significance but important for final documentation
- [ ] 5.2: Run full test suite (make tests)
- [ ] 5.3: Code review - check for style consistency with codebase
- [ ] 5.4: Final verification - all tests pass, documentation complete, no regressions

## Key Design Decisions to Confirm
- ~~Total operand bytes > size: should error or truncate?~~ **DECIDED**: Truncate to size, emit warning error, skip remaining operands
- Backward compatibility confirmed: old syntax `DEFS 10, 5` is seamlessly `DEFS 10` + one operand (5)
- Exact match is valid: `DEFS 1, 'x'` emits single byte, no error

## Testing Infrastructure Notes
- **Test runner behavior**: Copies .asm file to sandbox dir, runs assembly, compares generated .lst with provided .lst
- **Path references**: All paths in .lst must be local/relative (not absolute). Test fails if paths don't match
- **Error-free assembly**: If .asm assembles without errors but .lst is missing, test does pass (just assembling is then success), to verify also bytes the .bin or .lst must be present
- **Non-error-free assembly**: without .lst test will fail, with .lst the diff of resulting listing is decisive whether test failed or passed
- **.lst file setup**: Create matching .lst file alongside .asm. Initial .lst can be generated from DB version, then patched to reflect DEFS syntax
- **Patching .lst**: Only modify "source part" (ending of listing lines, after machine code bytes). Keep machine code bytes section unchanged from DB version if semantically identical
- **Testing both modes**: Use same .asm file with sections for both modes:
  - `DEVICE NONE` section for pipe/streaming mode
  - `DEVICE NOSLOT64K` section for virtual device mode
- Both sections can coexist in the test file and will be verified by the generated .lst

## Development Testing Workflow
- **Narrow scope**: During implementation, use `make tests TEST=parsing/defs` to test only DEFS-related tests
- **Gradual verification**: After each sub-step, run `make tests TEST=parsing` to verify parsing features for regressions
- **Full test suite**: Run full `make tests` regularly (this includes `parsing` as well) (at end of each phase) to catch cross-feature regressions
- **Test output**: Failing tests with .lst files display diffs in test run log (shows expected vs actual listing)
- **Disable colors**: Use `NOCOLOR=1` when logging (e.g., `make tests TEST=parsing/defs NOCOLOR=1`) to remove ANSI color codes from logs

## Implementation Strategy Notes
- **Phase approach**: Use "v2" variants initially to keep existing code isolated and safe during development
- **First priority**: Get feature working and fully test-covered
- **Progressive testing**: Implement in sub-steps, test narrowly (`TEST=parsing/defs`), then run broader (`TEST=parsing` or full suite) to catch regressions before moving to next step
- **Refactoring allowed after testing**: Once feature is complete and well-tested, refactoring to modify old APIs (GetBytes, etc.) is acceptable
- **Safety net**: Existing test coverage should catch any backward-compatibility issues if old API is modified, so changes can be attempted confidently
- **Decision point**: If refactoring to merge v2 back into original API is complex, acceptable to keep duplication

## Backward Compatibility & Risk Management
- **Struct.BLOCK field**: Similar but independent implementation. STRUCT already has TEXT field with curly-bracket init rules. BLOCK (aliased as `#`, `DS`, `DEFS` in struct context) has different semantics and would add unnecessary complexity to this PR.
- **Scope**: This PR focuses on standalone DEFS directive only, not struct field variants.

## Files to Modify
- **tests/parsing/defs_string_filler.asm** - test file (created immediately after Phase 1, before sjasm changes)
- **tests/parsing/defs_string_filler.lst** - expected listing output (generated via: `./sjasmplus --lst --lstlab=sort --color=off tests/parsing/defs_string_filler.asm`)
- **sjasm/directives.cpp** - DEFS directive handler (dirDEFS function)
- **sjasm/reader.cpp** - may reuse/adapt GetBytes or create variant for DEFS
- **docs/documentation.xml** - update DEFS syntax documentation
- (possibly) **sjasm/reader.h** - export helper functions if needed

## Key References
- **struct TEXT implementation**: `GetStructText()` in sjasm/reader.cpp (line ~736)
- **DB-like operand parsing**: `GetBytes()` in sjasm/reader.cpp
- **TEXT example**: tests/docs_examples/st_text.asm shows usage pattern
- **struct field types**: sjasm/tables.h (CStructureEntry2, EStructureMembers enum)
- **DEFS current implementation**: search "dirDEFS" in sjasm/directives.cpp

## Success Criteria
- [x] Issue #149 requirements implemented
- [ ] All existing DEFS tests still pass
- [ ] New DEFS operand tests pass (numeric, string, mixed, suffixes)
- [ ] Documentation updated with new DEFS syntax
- [ ] Both pipe mode and device mode work correctly
- [ ] No new warnings or errors in build
- [ ] Works on Linux, macOS, Windows

## Critical Questions & Gaps Identified (Post-Research)

**Key Findings from Source Code Analysis**:
1. ✅ **DEFB/DB Pattern is solid**: dirBYTE→getBytesWithCheck→GetBytes→EmitBytes pattern is clean and reusable
2. ✅ **GetBytes is fully featured**: Already handles strings, expressions, suffixes (Z/C), comma-separated operands, 128-byte limit
3. ✅ **EmitBytes is simple**: Just emits an array of bytes, terminates on -1 sentinel (BYTES_END_MARKER)
4. ✅ **EmitBlock pattern for padding**: Clear signature: EmitBlock(fillbyte, size, preserveDeviceMemory, emitMaxToListing)
5. ✅ **Integration design confirmed** (Approach A selected):
   - **Approach A (Recommended)**: Parse operands with GetBytes, emit them directly with EmitBytes, then call EmitBlock for padding
     ```
     DEFS 10, 1, 'x' → GetBytes([1, 'x', -1]) → EmitBytes([1, 'x']) → EmitBlock('x', 8)
     ```
     - Pros: Clean separation, reuses existing patterns, no array truncation logic needed
     - Cons: Two separate emission calls (but both happen in all passes identically)
   
   - **Approach B (Simpler fallback)**: Parse operands, compute filler byte, use existing EmitBlock for everything
     ```
     DEFS 10, 1, 'x' → GetBytes([1, 'x', -1]) → EmitBlock_v2(operand_array, size)
     ```
     - Pros: Single emission call, no EmitBlock changes needed
     - Cons: Requires new EmitBlock variant or truncation logic for overflow case
     
   **Design question: Which approach?** Approach A seems cleaner and truer to existing patterns.

6. ✅ **Two distinct overflow limits** (clarified by user):
   - **GetBytes 128-byte limit** (operand list parser array): Error "Over 128 bytes defined in single DB/DC/..."
     - This hits first if operand arguments are too long (e.g., too many values in list)
     - GetBytes will error before returning
   - **DEFS size limit** (explicit per directive): Checked AFTER GetBytes returns, BEFORE EmitBytes
     ```
     DEFS 5, 1, 2, 3, 4, 5, 6, 7, 8  → GetBytes returns [1,2,3,4,5,6,7,8,-1] successfully
                                        → Check: 8 bytes > DEFS size 5 → truncate to [1,2,3,4,5]
                                        → EmitBytes([1,2,3,4,5]) → filler_byte = 5
                                        → EmitBlock(5, 0) → no padding needed
     ```
   - **Action**: Truncate to DEFS size before emission, use last emitted byte as filler, report DEFS-specific overflow error (message format TBD - will be fine-tuned during implementation)

7. ✅ **Error messages - two scenarios** (clarified):
   - **GetBytes 128-byte limit error** (from line 690): "Over 128 bytes defined in single DB/DC/..." - auto-triggered by GetBytes, reused as-is
   - **DEFS size limit error**: Report when operand bytes exceed DEFS size (post-GetBytes, pre-EmitBytes)
     - Message format to be fine-tuned during implementation (TBD, will determine what context info is available)

8. ✅ **Backward compatibility is automatic**: DEFS 10, 5 → GetBytes([5, -1]) → EmitBytes([5]) → EmitBlock(5, 9)
   - This works with Approach A without any special-casing

9. ✅ **Pass-correctness** (clarified): All passes must advance program counter ($) by identical amount
   - Pass 1 & 2: Calculate $ advance, no byte emission
   - Pass 3: Actually emit bytes to device/stream with same $ advances
   - GetBytes operand parsing is deterministic (expressions evaluated in all passes, string literals are constants)
   - As long as operand count/size is identical in all passes, $ advances will match automatically

10. ✅ **struct TEXT reference and DEFS brace semantics** (clarified): DEFS is standalone directive with no braces—conceptually like implicit single set of curly braces if struct-related, but syntax is directive-specific. All comma-separated operands directly affect current DEFS block. No TEXT changes needed for this PR.

**Remaining Research Items** (if implementation encounters issues):
- [ ] Check if EmitBytes has any interaction with passes (single pass artifact?)
- [ ] Verify string suffix handling (Z, C) works through entire pipeline
- [ ] Confirm device memory preservation doesn't interfere with operand emission
- [ ] Determine available context for DEFS size overflow error message (source location, exact values)

**Implementation Confidence**: ~95% (after user clarification)
- Core architecture well-understood
- Reusable patterns identified
- Design approach confirmed (Approach A with GetBytes → truncate to DEFS size → EmitBytes → capture last byte as filler → EmitBlock)
- Two overflow limits clearly separated (128-byte operand list limit vs DEFS size limit)
- Edge cases mostly handled by existing infrastructure, except DEFS size overflow message format (TBD, low-risk)
